// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	amqp "github.com/streadway/amqp"
	mock "github.com/stretchr/testify/mock"

	model "github.com/softplan/tenkai-helm-api/pkg/dbms/model"

	rabbitmq "github.com/softplan/tenkai-helm-api/pkg/service/rabbitmq"
)

// RabbitInterface is an autogenerated mock type for the RabbitInterface type
type RabbitInterface struct {
	mock.Mock
}

// Bind provides a mock function with given fields: queueName, routingKey, exchange
func (_m *RabbitInterface) Bind(queueName string, routingKey string, exchange string) error {
	ret := _m.Called(queueName, routingKey, exchange)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(queueName, routingKey, exchange)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConsumeRepoQueue provides a mock function with given fields: queueName, fn, repo
func (_m *RabbitInterface) ConsumeRepoQueue(queueName string, fn rabbitmq.HandlerRepo, repo model.Repository) error {
	ret := _m.Called(queueName, fn, repo)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, rabbitmq.HandlerRepo, model.Repository) error); ok {
		r0 = rf(queueName, fn, repo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateFanoutExchange provides a mock function with given fields: name
func (_m *RabbitInterface) CreateFanoutExchange(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateQueue provides a mock function with given fields: queueName
func (_m *RabbitInterface) CreateQueue(queueName string) error {
	ret := _m.Called(queueName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(queueName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetChannel provides a mock function with given fields:
func (_m *RabbitInterface) GetChannel() *amqp.Channel {
	ret := _m.Called()

	var r0 *amqp.Channel
	if rf, ok := ret.Get(0).(func() *amqp.Channel); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*amqp.Channel)
		}
	}

	return r0
}

// GetConnection provides a mock function with given fields: uri
func (_m *RabbitInterface) GetConnection(uri string) *amqp.Connection {
	ret := _m.Called(uri)

	var r0 *amqp.Connection
	if rf, ok := ret.Get(0).(func(string) *amqp.Connection); ok {
		r0 = rf(uri)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*amqp.Connection)
		}
	}

	return r0
}

// GetConsumer provides a mock function with given fields: queue, consumer, autoAck, exclusive, noLocal, noWait, args
func (_m *RabbitInterface) GetConsumer(queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp.Table) (<-chan amqp.Delivery, error) {
	ret := _m.Called(queue, consumer, autoAck, exclusive, noLocal, noWait, args)

	var r0 <-chan amqp.Delivery
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, bool, bool, amqp.Table) <-chan amqp.Delivery); ok {
		r0 = rf(queue, consumer, autoAck, exclusive, noLocal, noWait, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan amqp.Delivery)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, bool, bool, bool, bool, amqp.Table) error); ok {
		r1 = rf(queue, consumer, autoAck, exclusive, noLocal, noWait, args)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Publish provides a mock function with given fields: exchange, key, mandatory, immediate, msg
func (_m *RabbitInterface) Publish(exchange string, key string, mandatory bool, immediate bool, msg amqp.Publishing) error {
	ret := _m.Called(exchange, key, mandatory, immediate, msg)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, amqp.Publishing) error); ok {
		r0 = rf(exchange, key, mandatory, immediate, msg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
